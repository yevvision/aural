<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test: Rate-Limit bei 15-Sekunden-Aufnahmen</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #1a1a1a; color: #fff; }
        .section { margin: 20px 0; padding: 15px; border: 1px solid #333; border-radius: 8px; }
        .button { padding: 10px 20px; margin: 5px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        .button:hover { background: #0056b3; }
        .success { color: #28a745; }
        .error { color: #dc3545; }
        .warning { color: #ffc107; }
        .info { color: #17a2b8; }
        pre { background: #2d2d2d; padding: 10px; border-radius: 4px; overflow-x: auto; max-height: 300px; }
        .upload { margin: 10px 0; padding: 10px; background: #333; border-radius: 4px; }
        .upload.allowed { border-left: 4px solid #28a745; }
        .upload.blocked { border-left: 4px solid #dc3545; }
        .upload.review { border-left: 4px solid #ffc107; }
        input[type="file"] { margin: 10px 0; }
        .rate-limit-test { background: #333; padding: 15px; border-radius: 8px; margin: 10px 0; }
        .rate-limit-test h4 { color: #ffc107; margin-bottom: 10px; }
        .test-scenario { background: #2d2d2d; padding: 15px; border-radius: 8px; margin: 10px 0; }
        .test-scenario h4 { color: #17a2b8; margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>‚è∞ Test: Rate-Limit bei 15-Sekunden-Aufnahmen</h1>
    
    <div class="section">
        <h2>üìä Problem</h2>
        <div class="error">
            <h3>‚ùå Vorher (falsch):</h3>
            <p><strong>Kurze Aufnahmen (< 15 Sek):</strong> Rate-Limit wird NICHT gepr√ºft ‚Üí nur "zu kurz" Nachricht</p>
            <p><strong>Lange Aufnahmen (> 15 Sek):</strong> Rate-Limit wird gepr√ºft ‚Üí "Upload-Frequenz √ºberschritten" Nachricht</p>
        </div>
        
        <div class="success">
            <h3>‚úÖ Jetzt (korrekt):</h3>
            <p><strong>Alle Aufnahmen:</strong> Rate-Limit wird IMMER zuerst gepr√ºft</p>
            <p><strong>4+ Uploads/30min:</strong> "Upload-Frequenz √ºberschritten" ‚Üí Pending-UI</p>
            <p><strong>< 15 Sek + Rate-Limit OK:</strong> "zu kurz" ‚Üí Pending-UI</p>
        </div>
    </div>
    
    <div class="section">
        <h2>üîÑ Test: 4 kurze Aufnahmen in 30 Minuten</h2>
        <div class="test-scenario">
            <h4>üìà Szenario: 4x 10-Sekunden-Aufnahmen</h4>
            <p>Teste ob Rate-Limit auch bei kurzen Aufnahmen greift</p>
            <button class="button" onclick="testShortUploads()">‚è∞ Kurze Aufnahmen testen</button>
            <div id="shortUploadsResult"></div>
        </div>
    </div>
    
    <div class="section">
        <h2>üîÑ Test: 4 lange Aufnahmen in 30 Minuten</h2>
        <div class="test-scenario">
            <h4>üìà Szenario: 4x 30-Sekunden-Aufnahmen</h4>
            <p>Teste ob Rate-Limit bei langen Aufnahmen weiterhin funktioniert</p>
            <button class="button" onclick="testLongUploads()">‚è∞ Lange Aufnahmen testen</button>
            <div id="longUploadsResult"></div>
        </div>
    </div>
    
    <div class="section">
        <h2>üîÑ Test: Gemischte Aufnahmen</h2>
        <div class="test-scenario">
            <h4>üìà Szenario: 2x kurz + 2x lang</h4>
            <p>Teste gemischte Aufnahmen: 10s, 10s, 30s, 30s</p>
            <button class="button" onclick="testMixedUploads()">‚è∞ Gemischte Aufnahmen testen</button>
            <div id="mixedUploadsResult"></div>
        </div>
    </div>
    
    <div class="section">
        <h2>üîÑ Reset</h2>
        <button class="button" onclick="resetAll()">üîÑ Alles zur√ºcksetzen</button>
        <div id="resetResult"></div>
    </div>

    <script>
        // Simuliere die UploadSecurityManager Klasse
        class MockUploadSecurityManager {
            constructor() {
                this.limits = {
                    maxUploadsPer30Min: 3,
                    maxUploadsPerDay: 5,
                    maxAudioMinutesPerDay: 120,
                    maxDuplicateCount: 5,
                    minAudioDuration: 15, // 15 Sekunden
                    maxAudioDuration: 1200 // 20 Minuten
                };
            }
            
            generateDeviceId() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                if (ctx) {
                    ctx.textBaseline = 'top';
                    ctx.font = '14px Arial';
                    ctx.fillText('Device fingerprint', 2, 2);
                }

                const fingerprint = [
                    navigator.userAgent,
                    navigator.language,
                    screen.width + 'x' + screen.height,
                    new Date().getTimezoneOffset(),
                    canvas.toDataURL()
                ].join('|');

                let hash = 0;
                for (let i = 0; i < fingerprint.length; i++) {
                    const char = fingerprint.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash).toString(36);
            }
            
            async calculateFileHash(file) {
                const buffer = await file.arrayBuffer();
                const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }
            
            loadDeviceStats(deviceId) {
                try {
                    const key = `aural_device_stats_${deviceId}`;
                    const data = localStorage.getItem(key);
                    if (data) {
                        const stats = JSON.parse(data);
                        if (stats.lastUpload30Min) stats.lastUpload30Min = new Date(stats.lastUpload30Min);
                        if (stats.lastUploadToday) stats.lastUploadToday = new Date(stats.lastUploadToday);
                        if (stats.lastReset) stats.lastReset = new Date(stats.lastReset);
                        return stats;
                    }
                } catch (error) {
                    console.warn('Failed to load device stats:', error);
                }
                return null;
            }
            
            createNewDeviceStats(deviceId) {
                return {
                    deviceId,
                    uploads30Min: 0,
                    uploadsToday: 0,
                    audioMinutesToday: 0,
                    lastUpload30Min: null,
                    lastUploadToday: null,
                    fileHashes: {},
                    lastReset: new Date()
                };
            }
            
            persistDeviceStats(deviceStats) {
                try {
                    const key = `aural_device_stats_${deviceStats.deviceId}`;
                    localStorage.setItem(key, JSON.stringify(deviceStats));
                } catch (error) {
                    console.warn('Failed to persist device stats:', error);
                }
            }
            
            checkRateLimits(deviceStats, duration) {
                const now = new Date();
                
                // 30-Minuten-Limit pr√ºfen
                if (deviceStats.lastUpload30Min) {
                    const timeDiff30Min = (now.getTime() - deviceStats.lastUpload30Min.getTime()) / (1000 * 60);
                    
                    if (timeDiff30Min < 30) {
                        if (deviceStats.uploads30Min >= this.limits.maxUploadsPer30Min) {
                            return {
                                allowed: false,
                                reason: 'Upload-Frequenz √ºberschritten - Aufnahme wird in Warteschlange aufgenommen',
                                requiresReview: true
                            };
                        }
                    } else {
                        deviceStats.uploads30Min = 0;
                        deviceStats.lastUpload30Min = null;
                    }
                }

                // Tages-Limit pr√ºfen
                if (deviceStats.lastUploadToday) {
                    const timeDiffToday = (now.getTime() - deviceStats.lastUploadToday.getTime()) / (1000 * 60 * 60 * 24);
                    if (timeDiffToday < 1) {
                        if (deviceStats.uploadsToday >= this.limits.maxUploadsPerDay) {
                            return {
                                allowed: false,
                                reason: 'Tages-Limit √ºberschritten - Aufnahme wird in Warteschlange aufgenommen',
                                requiresReview: true
                            };
                        }

                        const newAudioMinutes = deviceStats.audioMinutesToday + Math.round(duration / 60);
                        if (newAudioMinutes > this.limits.maxAudioMinutesPerDay) {
                            return {
                                allowed: false,
                                reason: 'Audio-Minuten-Limit √ºberschritten - Aufnahme wird in Warteschlange aufgenommen',
                                requiresReview: true
                            };
                        }
                    } else {
                        deviceStats.uploadsToday = 0;
                        deviceStats.audioMinutesToday = 0;
                        deviceStats.lastUploadToday = null;
                    }
                }

                return { allowed: true, requiresReview: false };
            }
            
            updateDeviceStatsAfterUpload(deviceStats, fileHash, duration) {
                const now = new Date();
                
                deviceStats.uploads30Min++;
                deviceStats.uploadsToday++;
                deviceStats.audioMinutesToday += Math.round(duration / 60);
                
                deviceStats.lastUpload30Min = now;
                deviceStats.lastUploadToday = now;
                
                deviceStats.fileHashes[fileHash] = (deviceStats.fileHashes[fileHash] || 0) + 1;
                
                this.persistDeviceStats(deviceStats);
            }
            
            async checkUploadSecurity(file, duration) {
                const deviceId = this.generateDeviceId();
                const fileHash = await this.calculateFileHash(file);
                
                let deviceStats = this.loadDeviceStats(deviceId);
                if (!deviceStats) {
                    deviceStats = this.createNewDeviceStats(deviceId);
                }
                
                console.log('üîê Security Check - Duration:', duration, 'seconds');

                // Rate-Limits ZUERST pr√ºfen (unabh√§ngig von der Dauer)
                const rateLimitCheck = this.checkRateLimits(deviceStats, duration);
                if (!rateLimitCheck.allowed) {
                    return {
                        allowed: false,
                        reason: rateLimitCheck.reason,
                        requiresReview: true,
                        duplicateCheck: { isDuplicate: false, duplicateCount: 0, isSuspicious: false },
                        deviceStats
                    };
                }

                // 15-Sekunden-Mindestdauer pr√ºfen
                if (duration < this.limits.minAudioDuration) {
                    return {
                        allowed: true,
                        reason: 'Deine Aufnahme wird jetzt gepr√ºft. Das dauert nur einen Moment.',
                        requiresReview: true,
                        duplicateCheck: { isDuplicate: false, duplicateCount: 0, isSuspicious: false },
                        deviceStats
                    };
                }

                // 20-Minuten-Maximaldauer pr√ºfen
                if (duration > this.limits.maxAudioDuration) {
                    return {
                        allowed: true,
                        reason: 'Aufnahme l√§nger als 20 Minuten - Sicherheitspr√ºfung erforderlich',
                        requiresReview: true,
                        duplicateCheck: { isDuplicate: false, duplicateCount: 0, isSuspicious: false },
                        deviceStats
                    };
                }

                const duplicateCount = deviceStats.fileHashes[fileHash] || 0;
                const duplicateCheck = {
                    isDuplicate: duplicateCount > 0,
                    duplicateCount,
                    isSuspicious: duplicateCount >= this.limits.maxDuplicateCount
                };

                const requiresReview = duplicateCheck.isSuspicious || rateLimitCheck.requiresReview;
                const allowed = rateLimitCheck.allowed && !duplicateCheck.isSuspicious;

                return {
                    allowed,
                    reason: allowed ? undefined : (rateLimitCheck.reason || 'Suspicious duplicate uploads'),
                    requiresReview,
                    duplicateCheck,
                    deviceStats
                };
            }
        }

        const securityManager = new MockUploadSecurityManager();

        async function testShortUploads() {
            let html = '<div class="info"><h3>‚è∞ Kurze Aufnahmen Test (4x 10 Sekunden)</h3></div>';
            
            // Simuliere 4 kurze Uploads in 30 Minuten
            for (let i = 1; i <= 4; i++) {
                const result = await securityManager.checkUploadSecurity(new File([''], 'test.wav'), 10);
                
                let statusClass = 'allowed';
                if (!result.allowed) statusClass = 'blocked';
                else if (result.requiresReview) statusClass = 'review';
                
                const status = result.allowed ? (result.requiresReview ? '‚ö†Ô∏è Review' : '‚úÖ OK') : '‚ùå Blockiert';
                
                html += `
                    <div class="upload ${statusClass}">
                        <h4>Upload ${i}/4 (10 Sekunden)</h4>
                        <p><strong>Status:</strong> ${status}</p>
                        <p><strong>Grund:</strong> ${result.reason || 'Kein Grund'}</p>
                        <p><strong>Review erforderlich:</strong> ${result.requiresReview ? 'Ja' : 'Nein'}</p>
                        <p><strong>30min Z√§hler:</strong> ${result.deviceStats.uploads30Min}</p>
                    </div>
                `;
                
                if (result.allowed) {
                    const fileHash = await securityManager.calculateFileHash(new File([''], 'test.wav'));
                    securityManager.updateDeviceStatsAfterUpload(result.deviceStats, fileHash, 10);
                }
            }
            
            document.getElementById('shortUploadsResult').innerHTML = html;
        }

        async function testLongUploads() {
            let html = '<div class="info"><h3>‚è∞ Lange Aufnahmen Test (4x 30 Sekunden)</h3></div>';
            
            // Simuliere 4 lange Uploads in 30 Minuten
            for (let i = 1; i <= 4; i++) {
                const result = await securityManager.checkUploadSecurity(new File([''], 'test.wav'), 30);
                
                let statusClass = 'allowed';
                if (!result.allowed) statusClass = 'blocked';
                else if (result.requiresReview) statusClass = 'review';
                
                const status = result.allowed ? (result.requiresReview ? '‚ö†Ô∏è Review' : '‚úÖ OK') : '‚ùå Blockiert';
                
                html += `
                    <div class="upload ${statusClass}">
                        <h4>Upload ${i}/4 (30 Sekunden)</h4>
                        <p><strong>Status:</strong> ${status}</p>
                        <p><strong>Grund:</strong> ${result.reason || 'Kein Grund'}</p>
                        <p><strong>Review erforderlich:</strong> ${result.requiresReview ? 'Ja' : 'Nein'}</p>
                        <p><strong>30min Z√§hler:</strong> ${result.deviceStats.uploads30Min}</p>
                    </div>
                `;
                
                if (result.allowed) {
                    const fileHash = await securityManager.calculateFileHash(new File([''], 'test.wav'));
                    securityManager.updateDeviceStatsAfterUpload(result.deviceStats, fileHash, 30);
                }
            }
            
            document.getElementById('longUploadsResult').innerHTML = html;
        }

        async function testMixedUploads() {
            let html = '<div class="info"><h3>‚è∞ Gemischte Aufnahmen Test (2x kurz + 2x lang)</h3></div>';
            
            const durations = [10, 10, 30, 30]; // 2x kurz, 2x lang
            
            for (let i = 0; i < durations.length; i++) {
                const duration = durations[i];
                const result = await securityManager.checkUploadSecurity(new File([''], 'test.wav'), duration);
                
                let statusClass = 'allowed';
                if (!result.allowed) statusClass = 'blocked';
                else if (result.requiresReview) statusClass = 'review';
                
                const status = result.allowed ? (result.requiresReview ? '‚ö†Ô∏è Review' : '‚úÖ OK') : '‚ùå Blockiert';
                
                html += `
                    <div class="upload ${statusClass}">
                        <h4>Upload ${i + 1}/4 (${duration} Sekunden)</h4>
                        <p><strong>Status:</strong> ${status}</p>
                        <p><strong>Grund:</strong> ${result.reason || 'Kein Grund'}</p>
                        <p><strong>Review erforderlich:</strong> ${result.requiresReview ? 'Ja' : 'Nein'}</p>
                        <p><strong>30min Z√§hler:</strong> ${result.deviceStats.uploads30Min}</p>
                    </div>
                `;
                
                if (result.allowed) {
                    const fileHash = await securityManager.calculateFileHash(new File([''], 'test.wav'));
                    securityManager.updateDeviceStatsAfterUpload(result.deviceStats, fileHash, duration);
                }
            }
            
            document.getElementById('mixedUploadsResult').innerHTML = html;
        }

        function resetAll() {
            const deviceId = securityManager.generateDeviceId();
            const key = `aural_device_stats_${deviceId}`;
            localStorage.removeItem(key);
            document.getElementById('resetResult').innerHTML = '<div class="success">‚úÖ Alle Z√§hler zur√ºckgesetzt</div>';
        }

        // Initialisierung
        console.log('üöÄ Rate-Limit 15-Sekunden Test System initialisiert');
    </script>
</body>
</html>
